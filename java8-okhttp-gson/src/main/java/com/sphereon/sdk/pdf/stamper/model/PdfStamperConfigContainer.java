/*
 * PDF stamper
 * The PDF Stamper API enables the possibility to add both static and dynamic stamps on existing PDFs. The stamps can consist of one or more barcode, hyperlink, image, line or text elements.    The flow is generally as follows:  1. Make a configuration containing the stamp information  2. Create a job specifying the desired configuration  3. Add one or more PDF files to the job  4. Start the job for processing  5. Retrieve the processed files    Full API Documentation: https://docs.sphereon.com/api/pdf-stamper/0.2  Interactive testing: A web based test console is available in the Sphereon API Store at https://store.sphereon.com
 *
 * OpenAPI spec version: 0.2
 * Contact: dev@sphereon.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.sphereon.sdk.pdf.stamper.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.sphereon.sdk.pdf.stamper.model.BlockchainConfig;
import com.sphereon.sdk.pdf.stamper.model.PdfStamperConfig;
import com.sphereon.sdk.pdf.stamper.model.StreamLocation;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.List;

/**
 * Container with the PDF stamper configuration
 */
@ApiModel(description = "Container with the PDF stamper configuration")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2020-01-03T17:44:37.086+01:00")
public class PdfStamperConfigContainer {
  @SerializedName("registeredResources")
  private List<StreamLocation> registeredResources = null;

  @SerializedName("creationTime")
  private OffsetDateTime creationTime = null;

  @SerializedName("blockchainConfig")
  private BlockchainConfig blockchainConfig = null;

  @SerializedName("configId")
  private String configId = null;

  @SerializedName("name")
  private String name = null;

  @SerializedName("updateTime")
  private OffsetDateTime updateTime = null;

  /**
   * The status of the configStatus action
   */
  @JsonAdapter(ConfigStatusEnum.Adapter.class)
  public enum ConfigStatusEnum {
    CREATED("CREATED"),
    
    UPDATED("UPDATED"),
    
    RESOURCE_UPLOADED("RESOURCE_UPLOADED"),
    
    ERROR("ERROR"),
    
    DELETED("DELETED"),
    
    DONE("DONE");

    private String value;

    ConfigStatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ConfigStatusEnum fromValue(String text) {
      for (ConfigStatusEnum b : ConfigStatusEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<ConfigStatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ConfigStatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ConfigStatusEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ConfigStatusEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("configStatus")
  private ConfigStatusEnum configStatus = null;

  @SerializedName("pdfStamperConfig")
  private PdfStamperConfig pdfStamperConfig = null;

  @SerializedName("statusMessage")
  private String statusMessage = null;

  public PdfStamperConfigContainer registeredResources(List<StreamLocation> registeredResources) {
    this.registeredResources = registeredResources;
    return this;
  }

  public PdfStamperConfigContainer addRegisteredResourcesItem(StreamLocation registeredResourcesItem) {
    if (this.registeredResources == null) {
      this.registeredResources = new ArrayList<>();
    }
    this.registeredResources.add(registeredResourcesItem);
    return this;
  }

   /**
   * Get registeredResources
   * @return registeredResources
  **/
  @ApiModelProperty(value = "")
  public List<StreamLocation> getRegisteredResources() {
    return registeredResources;
  }

  public void setRegisteredResources(List<StreamLocation> registeredResources) {
    this.registeredResources = registeredResources;
  }

   /**
   * The creation date/time of the initial configuration in ISO 8601 format
   * @return creationTime
  **/
  @ApiModelProperty(value = "The creation date/time of the initial configuration in ISO 8601 format")
  public OffsetDateTime getCreationTime() {
    return creationTime;
  }

  public PdfStamperConfigContainer blockchainConfig(BlockchainConfig blockchainConfig) {
    this.blockchainConfig = blockchainConfig;
    return this;
  }

   /**
   * Optional blockchain proof configuration
   * @return blockchainConfig
  **/
  @ApiModelProperty(value = "Optional blockchain proof configuration")
  public BlockchainConfig getBlockchainConfig() {
    return blockchainConfig;
  }

  public void setBlockchainConfig(BlockchainConfig blockchainConfig) {
    this.blockchainConfig = blockchainConfig;
  }

   /**
   * The configuration id
   * @return configId
  **/
  @ApiModelProperty(required = true, value = "The configuration id")
  public String getConfigId() {
    return configId;
  }

  public PdfStamperConfigContainer name(String name) {
    this.name = name;
    return this;
  }

   /**
   * An optional configuration name
   * @return name
  **/
  @ApiModelProperty(value = "An optional configuration name")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

   /**
   * The last update date/time of this configuration in ISO 8601 format
   * @return updateTime
  **/
  @ApiModelProperty(value = "The last update date/time of this configuration in ISO 8601 format")
  public OffsetDateTime getUpdateTime() {
    return updateTime;
  }

   /**
   * The status of the configStatus action
   * @return configStatus
  **/
  @ApiModelProperty(value = "The status of the configStatus action")
  public ConfigStatusEnum getConfigStatus() {
    return configStatus;
  }

  public PdfStamperConfigContainer pdfStamperConfig(PdfStamperConfig pdfStamperConfig) {
    this.pdfStamperConfig = pdfStamperConfig;
    return this;
  }

   /**
   * The PDF stamper configuration
   * @return pdfStamperConfig
  **/
  @ApiModelProperty(required = true, value = "The PDF stamper configuration")
  public PdfStamperConfig getPdfStamperConfig() {
    return pdfStamperConfig;
  }

  public void setPdfStamperConfig(PdfStamperConfig pdfStamperConfig) {
    this.pdfStamperConfig = pdfStamperConfig;
  }

   /**
   * A status message, which can be informational, warning or error. A message here does not indicate an error per se
   * @return statusMessage
  **/
  @ApiModelProperty(value = "A status message, which can be informational, warning or error. A message here does not indicate an error per se")
  public String getStatusMessage() {
    return statusMessage;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PdfStamperConfigContainer pdfStamperConfigContainer = (PdfStamperConfigContainer) o;
    return Objects.equals(this.registeredResources, pdfStamperConfigContainer.registeredResources) &&
        Objects.equals(this.creationTime, pdfStamperConfigContainer.creationTime) &&
        Objects.equals(this.blockchainConfig, pdfStamperConfigContainer.blockchainConfig) &&
        Objects.equals(this.configId, pdfStamperConfigContainer.configId) &&
        Objects.equals(this.name, pdfStamperConfigContainer.name) &&
        Objects.equals(this.updateTime, pdfStamperConfigContainer.updateTime) &&
        Objects.equals(this.configStatus, pdfStamperConfigContainer.configStatus) &&
        Objects.equals(this.pdfStamperConfig, pdfStamperConfigContainer.pdfStamperConfig) &&
        Objects.equals(this.statusMessage, pdfStamperConfigContainer.statusMessage);
  }

  @Override
  public int hashCode() {
    return Objects.hash(registeredResources, creationTime, blockchainConfig, configId, name, updateTime, configStatus, pdfStamperConfig, statusMessage);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PdfStamperConfigContainer {\n");
    
    sb.append("    registeredResources: ").append(toIndentedString(registeredResources)).append("\n");
    sb.append("    creationTime: ").append(toIndentedString(creationTime)).append("\n");
    sb.append("    blockchainConfig: ").append(toIndentedString(blockchainConfig)).append("\n");
    sb.append("    configId: ").append(toIndentedString(configId)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    updateTime: ").append(toIndentedString(updateTime)).append("\n");
    sb.append("    configStatus: ").append(toIndentedString(configStatus)).append("\n");
    sb.append("    pdfStamperConfig: ").append(toIndentedString(pdfStamperConfig)).append("\n");
    sb.append("    statusMessage: ").append(toIndentedString(statusMessage)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

