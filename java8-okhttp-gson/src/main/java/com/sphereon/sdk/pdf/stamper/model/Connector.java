/*
 * PDF stamper
 * The PDF Stamper API enables the possibility to add both static and dynamic stamps on existing PDFs. The stamps can consist of one or more barcode, hyperlink, image, line or text elements.    The flow is generally as follows:  1. Make a configuration containing the stamp information  2. Create a job specifying the desired configuration  3. Add one or more PDF files to the job  4. Start the job for processing  5. Retrieve the processed files    Full API Documentation: https://docs.sphereon.com/api/pdf-stamper/0.2  Interactive testing: A web based test console is available in the Sphereon API Store at https://store.sphereon.com
 *
 * OpenAPI spec version: 0.2
 * Contact: dev@sphereon.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.sphereon.sdk.pdf.stamper.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.sphereon.sdk.pdf.stamper.model.Point;
import com.sphereon.sdk.pdf.stamper.model.StampComponent;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * Connection between components containing anchor points and offset of the component
 */
@ApiModel(description = "Connection between components containing anchor points and offset of the component")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2020-01-03T17:44:37.086+01:00")
public class Connector {
  @SerializedName("components")
  private List<StampComponent> components = null;

  @SerializedName("offset")
  private Point offset = null;

  /**
   * The horizontal anchor point to which the components are connected
   */
  @JsonAdapter(HorizontalAnchorPointEnum.Adapter.class)
  public enum HorizontalAnchorPointEnum {
    LEFT("LEFT"),
    
    CENTER("CENTER"),
    
    RIGHT("RIGHT");

    private String value;

    HorizontalAnchorPointEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static HorizontalAnchorPointEnum fromValue(String text) {
      for (HorizontalAnchorPointEnum b : HorizontalAnchorPointEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<HorizontalAnchorPointEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final HorizontalAnchorPointEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public HorizontalAnchorPointEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return HorizontalAnchorPointEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("horizontalAnchorPoint")
  private HorizontalAnchorPointEnum horizontalAnchorPoint = null;

  /**
   * The vertical anchor point to which the components are connected
   */
  @JsonAdapter(VerticalAnchorPointEnum.Adapter.class)
  public enum VerticalAnchorPointEnum {
    TOP("TOP"),
    
    MIDDLE("MIDDLE"),
    
    BOTTOM("BOTTOM");

    private String value;

    VerticalAnchorPointEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static VerticalAnchorPointEnum fromValue(String text) {
      for (VerticalAnchorPointEnum b : VerticalAnchorPointEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<VerticalAnchorPointEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final VerticalAnchorPointEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public VerticalAnchorPointEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return VerticalAnchorPointEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("verticalAnchorPoint")
  private VerticalAnchorPointEnum verticalAnchorPoint = null;

  public Connector components(List<StampComponent> components) {
    this.components = components;
    return this;
  }

  public Connector addComponentsItem(StampComponent componentsItem) {
    if (this.components == null) {
      this.components = new ArrayList<>();
    }
    this.components.add(componentsItem);
    return this;
  }

   /**
   * Get components
   * @return components
  **/
  @ApiModelProperty(value = "")
  public List<StampComponent> getComponents() {
    return components;
  }

  public void setComponents(List<StampComponent> components) {
    this.components = components;
  }

  public Connector offset(Point offset) {
    this.offset = offset;
    return this;
  }

   /**
   * The offset op the components relative to the parent component
   * @return offset
  **/
  @ApiModelProperty(value = "The offset op the components relative to the parent component")
  public Point getOffset() {
    return offset;
  }

  public void setOffset(Point offset) {
    this.offset = offset;
  }

  public Connector horizontalAnchorPoint(HorizontalAnchorPointEnum horizontalAnchorPoint) {
    this.horizontalAnchorPoint = horizontalAnchorPoint;
    return this;
  }

   /**
   * The horizontal anchor point to which the components are connected
   * @return horizontalAnchorPoint
  **/
  @ApiModelProperty(required = true, value = "The horizontal anchor point to which the components are connected")
  public HorizontalAnchorPointEnum getHorizontalAnchorPoint() {
    return horizontalAnchorPoint;
  }

  public void setHorizontalAnchorPoint(HorizontalAnchorPointEnum horizontalAnchorPoint) {
    this.horizontalAnchorPoint = horizontalAnchorPoint;
  }

  public Connector verticalAnchorPoint(VerticalAnchorPointEnum verticalAnchorPoint) {
    this.verticalAnchorPoint = verticalAnchorPoint;
    return this;
  }

   /**
   * The vertical anchor point to which the components are connected
   * @return verticalAnchorPoint
  **/
  @ApiModelProperty(required = true, value = "The vertical anchor point to which the components are connected")
  public VerticalAnchorPointEnum getVerticalAnchorPoint() {
    return verticalAnchorPoint;
  }

  public void setVerticalAnchorPoint(VerticalAnchorPointEnum verticalAnchorPoint) {
    this.verticalAnchorPoint = verticalAnchorPoint;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Connector connector = (Connector) o;
    return Objects.equals(this.components, connector.components) &&
        Objects.equals(this.offset, connector.offset) &&
        Objects.equals(this.horizontalAnchorPoint, connector.horizontalAnchorPoint) &&
        Objects.equals(this.verticalAnchorPoint, connector.verticalAnchorPoint);
  }

  @Override
  public int hashCode() {
    return Objects.hash(components, offset, horizontalAnchorPoint, verticalAnchorPoint);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Connector {\n");
    
    sb.append("    components: ").append(toIndentedString(components)).append("\n");
    sb.append("    offset: ").append(toIndentedString(offset)).append("\n");
    sb.append("    horizontalAnchorPoint: ").append(toIndentedString(horizontalAnchorPoint)).append("\n");
    sb.append("    verticalAnchorPoint: ").append(toIndentedString(verticalAnchorPoint)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

