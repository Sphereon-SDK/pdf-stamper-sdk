/*
 * PDF stamper
 * The PDF Stamper API enables the possibility to add both static and dynamic stamps on existing PDFs. The stamps can consist of one or more barcode, hyperlink, image, line or text elements.    The flow is generally as follows:  1. Make a configuration containing the stamp information  2. Create a job specifying the desired configuration  3. Add one or more PDF files to the job  4. Start the job for processing  5. Retrieve the processed files    Full API Documentation: https://docs.sphereon.com/api/pdf-stamper/1.0  Interactive testing: A web based test console is available in the Sphereon API Store at https://store.sphereon.com
 *
 * OpenAPI spec version: 1.0
 * Contact: dev@sphereon.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.sphereon.sdk.pdf.stamper.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.sphereon.sdk.pdf.stamper.model.Connector;
import com.sphereon.sdk.pdf.stamper.model.ImageComponent;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;

/**
 * VisibleSignature
 */
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2021-03-12T10:33:42.564+01:00")
public class VisibleSignature {
  /**
   * The page for the visible signature (multiple pages is not supported, call multiple stamp configurations if that is desired)
   */
  @JsonAdapter(PageSelectorEnum.Adapter.class)
  public enum PageSelectorEnum {
    FIRST_PAGE("FIRST_PAGE"),
    
    LAST_PAGE("LAST_PAGE"),
    
    EVEN_PAGES("EVEN_PAGES"),
    
    ODD_PAGES("ODD_PAGES"),
    
    ALL_PAGES("ALL_PAGES"),
    
    SPECIFIC_PAGES("SPECIFIC_PAGES");

    private String value;

    PageSelectorEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PageSelectorEnum fromValue(String text) {
      for (PageSelectorEnum b : PageSelectorEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<PageSelectorEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PageSelectorEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PageSelectorEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return PageSelectorEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("pageSelector")
  private PageSelectorEnum pageSelector = null;

  @SerializedName("connector")
  private Connector connector = null;

  @SerializedName("imageComponent")
  private ImageComponent imageComponent = null;

  public VisibleSignature pageSelector(PageSelectorEnum pageSelector) {
    this.pageSelector = pageSelector;
    return this;
  }

   /**
   * The page for the visible signature (multiple pages is not supported, call multiple stamp configurations if that is desired)
   * @return pageSelector
  **/
  @ApiModelProperty(value = "The page for the visible signature (multiple pages is not supported, call multiple stamp configurations if that is desired)")
  public PageSelectorEnum getPageSelector() {
    return pageSelector;
  }

  public void setPageSelector(PageSelectorEnum pageSelector) {
    this.pageSelector = pageSelector;
  }

  public VisibleSignature connector(Connector connector) {
    this.connector = connector;
    return this;
  }

   /**
   * The connector (location) for the visible signature
   * @return connector
  **/
  @ApiModelProperty(value = "The connector (location) for the visible signature")
  public Connector getConnector() {
    return connector;
  }

  public void setConnector(Connector connector) {
    this.connector = connector;
  }

  public VisibleSignature imageComponent(ImageComponent imageComponent) {
    this.imageComponent = imageComponent;
    return this;
  }

   /**
   * The image for the visible signature
   * @return imageComponent
  **/
  @ApiModelProperty(value = "The image for the visible signature")
  public ImageComponent getImageComponent() {
    return imageComponent;
  }

  public void setImageComponent(ImageComponent imageComponent) {
    this.imageComponent = imageComponent;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    VisibleSignature visibleSignature = (VisibleSignature) o;
    return Objects.equals(this.pageSelector, visibleSignature.pageSelector) &&
        Objects.equals(this.connector, visibleSignature.connector) &&
        Objects.equals(this.imageComponent, visibleSignature.imageComponent);
  }

  @Override
  public int hashCode() {
    return Objects.hash(pageSelector, connector, imageComponent);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class VisibleSignature {\n");
    
    sb.append("    pageSelector: ").append(toIndentedString(pageSelector)).append("\n");
    sb.append("    connector: ").append(toIndentedString(connector)).append("\n");
    sb.append("    imageComponent: ").append(toIndentedString(imageComponent)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

