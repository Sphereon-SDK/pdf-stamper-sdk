/*
 * PDF stamper
 * The PDF Stamper API enables the possibility to add both static and dynamic stamps on existing PDFs. The stamps can consist of one or more barcode, hyperlink, image, line or text elements.    The flow is generally as follows:  1. Make a configuration containing the stamp information  2. Create a job specifying the desired configuration  3. Add one or more PDF files to the job  4. Start the job for processing  5. Retrieve the processed files    Full API Documentation: https://docs.sphereon.com/api/pdf-stamper/1.0  Interactive testing: A web based test console is available in the Sphereon API Store at https://store.sphereon.com
 *
 * OpenAPI spec version: 1.0
 * Contact: dev@sphereon.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.sphereon.sdk.pdf.stamper.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.List;

/**
 * Lifecycle settings. When no lifecycle settings are supplied, the job and files will be deleted directly after retrieval of the file
 */
@ApiModel(description = "Lifecycle settings. When no lifecycle settings are supplied, the job and files will be deleted directly after retrieval of the file")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2020-03-09T04:53:18.701Z")
public class Lifecycle {
  /**
   * Gets or Sets applicableJobStatuses
   */
  @JsonAdapter(ApplicableJobStatusesEnum.Adapter.class)
  public enum ApplicableJobStatusesEnum {
    CREATED("CREATED"),
    
    INPUTS_UPLOADED("INPUTS_UPLOADED"),
    
    PROCESSING("PROCESSING"),
    
    DONE("DONE"),
    
    ERROR("ERROR"),
    
    DELETED("DELETED");

    private String value;

    ApplicableJobStatusesEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ApplicableJobStatusesEnum fromValue(String text) {
      for (ApplicableJobStatusesEnum b : ApplicableJobStatusesEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<ApplicableJobStatusesEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ApplicableJobStatusesEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ApplicableJobStatusesEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ApplicableJobStatusesEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("applicableJobStatuses")
  private List<ApplicableJobStatusesEnum> applicableJobStatuses = null;

  @SerializedName("actionTime")
  private OffsetDateTime actionTime = null;

  /**
   * The action to perform. Currently only delete is supported
   */
  @JsonAdapter(ActionEnum.Adapter.class)
  public enum ActionEnum {
    DELETE("DELETE"),
    
    NONE("NONE");

    private String value;

    ActionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ActionEnum fromValue(String text) {
      for (ActionEnum b : ActionEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<ActionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ActionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ActionEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ActionEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("action")
  private ActionEnum action = null;

  /**
   * Determine when to delete the job and associated files.  RETRIEVAL means delete directly after retrieving the PDF file. When the file has not been retrieved before the action time, it will be deleted regardless.  Time means, delete on specific time, regardless of whether it has been processed
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    RETRIEVAL("RETRIEVAL"),
    
    TIME("TIME");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static TypeEnum fromValue(String text) {
      for (TypeEnum b : TypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return TypeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("type")
  private TypeEnum type = null;

  public Lifecycle applicableJobStatuses(List<ApplicableJobStatusesEnum> applicableJobStatuses) {
    this.applicableJobStatuses = applicableJobStatuses;
    return this;
  }

  public Lifecycle addApplicableJobStatusesItem(ApplicableJobStatusesEnum applicableJobStatusesItem) {
    if (this.applicableJobStatuses == null) {
      this.applicableJobStatuses = new ArrayList<>();
    }
    this.applicableJobStatuses.add(applicableJobStatusesItem);
    return this;
  }

   /**
   * Job status needs to be in this list in order for the action to be performed!
   * @return applicableJobStatuses
  **/
  @ApiModelProperty(value = "Job status needs to be in this list in order for the action to be performed!")
  public List<ApplicableJobStatusesEnum> getApplicableJobStatuses() {
    return applicableJobStatuses;
  }

  public void setApplicableJobStatuses(List<ApplicableJobStatusesEnum> applicableJobStatuses) {
    this.applicableJobStatuses = applicableJobStatuses;
  }

  public Lifecycle actionTime(OffsetDateTime actionTime) {
    this.actionTime = actionTime;
    return this;
  }

   /**
   * The time at which the job and files will be deleted, regardless of whether it has been retrieved or not. Maximal time is 1 day from job creation
   * @return actionTime
  **/
  @ApiModelProperty(value = "The time at which the job and files will be deleted, regardless of whether it has been retrieved or not. Maximal time is 1 day from job creation")
  public OffsetDateTime getActionTime() {
    return actionTime;
  }

  public void setActionTime(OffsetDateTime actionTime) {
    this.actionTime = actionTime;
  }

  public Lifecycle action(ActionEnum action) {
    this.action = action;
    return this;
  }

   /**
   * The action to perform. Currently only delete is supported
   * @return action
  **/
  @ApiModelProperty(value = "The action to perform. Currently only delete is supported")
  public ActionEnum getAction() {
    return action;
  }

  public void setAction(ActionEnum action) {
    this.action = action;
  }

  public Lifecycle type(TypeEnum type) {
    this.type = type;
    return this;
  }

   /**
   * Determine when to delete the job and associated files.  RETRIEVAL means delete directly after retrieving the PDF file. When the file has not been retrieved before the action time, it will be deleted regardless.  Time means, delete on specific time, regardless of whether it has been processed
   * @return type
  **/
  @ApiModelProperty(value = "Determine when to delete the job and associated files.  RETRIEVAL means delete directly after retrieving the PDF file. When the file has not been retrieved before the action time, it will be deleted regardless.  Time means, delete on specific time, regardless of whether it has been processed")
  public TypeEnum getType() {
    return type;
  }

  public void setType(TypeEnum type) {
    this.type = type;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Lifecycle lifecycle = (Lifecycle) o;
    return Objects.equals(this.applicableJobStatuses, lifecycle.applicableJobStatuses) &&
        Objects.equals(this.actionTime, lifecycle.actionTime) &&
        Objects.equals(this.action, lifecycle.action) &&
        Objects.equals(this.type, lifecycle.type);
  }

  @Override
  public int hashCode() {
    return Objects.hash(applicableJobStatuses, actionTime, action, type);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Lifecycle {\n");
    
    sb.append("    applicableJobStatuses: ").append(toIndentedString(applicableJobStatuses)).append("\n");
    sb.append("    actionTime: ").append(toIndentedString(actionTime)).append("\n");
    sb.append("    action: ").append(toIndentedString(action)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

